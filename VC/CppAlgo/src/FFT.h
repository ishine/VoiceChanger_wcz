#pragma once
#include <Eigen/Dense>
#include <unsupported/Eigen/FFT>
#include <type_traits>
#include "concat.h"
#include "types.h"

/**
  * Fast fourier transformation to implement the fft function in MATLAB for a vector input.
  *@tparam ComplexOutputVector the output complex vector type, default to be Eigen::RowVectorXcd
  *@tparam ComplexInputDerived input vector type
  *@param X input vector
  *@return a vector generated by Fourier transform of the input vector 
  *@ramark Unlike fft of MATLAB, this function only supports vector input and vector output. See https://www.mathworks.com/help/matlab/ref/fft.html.
*/
template<typename ComplexOutputVector = Eigen::TRowVectorXc, typename ComplexInputDerived>
ComplexOutputVector fft(const Eigen::MatrixBase<ComplexInputDerived>& X)
{
	EIGEN_STATIC_ASSERT_VECTOR_ONLY(ComplexInputDerived);
	Eigen::FFT<typename ComplexOutputVector::RealScalar> fftTransformation;
	ComplexOutputVector output(X.size());
	fftTransformation.fwd(output, X);
	return output;
}

/**
* n-point Fast fourier transformation to implement the fft function in MATLAB for a vector input.
*@tparam ComplexOutputVector the output complex vector type, default to be Eigen::RowVectorXcd
*@tparam ComplexInputDerived input vector type
*@param X input vector
*@param n number of points
*@return a vector generated by Fourier transform of the input vector
*@ramark Unlike fft of MATLAB, this function only supports vector input and vector output. See https://www.mathworks.com/help/matlab/ref/fft.html.
*/
template<typename ComplexOutputVector = Eigen::TRowVectorXc, typename ComplexInputDerived>
ComplexOutputVector fft(const Eigen::MatrixBase<ComplexInputDerived>& X, int n)
{
	EIGEN_STATIC_ASSERT_VECTOR_ONLY(ComplexInputDerived);
	assert(n >= X.size());
	if (n == X.size())
	{
		return fft<ComplexOutputVector>(X );
	}
	// pad zero to make n points
	constexpr Eigen::DirectionType dir = ComplexInputDerived::RowsAtCompileTime == 1 ? Eigen::Horizontal : Eigen::Vertical;
	return fft<ComplexOutputVector>(concat<ComplexInputDerived>(X, ComplexInputDerived::Zero(n - X.size()), dir));
}


/**
* Fast fourier transformation to implement the fft function in MATLAB for a matrix input.
*@tparam OutputDerived the output complex matrix type, default to be Eigen::TMatrixXc
*@tparam ComplexInputDerived input vector type
*@param X input matrix
*@param n  n-point DFT
*@param dim specify the dimension for Fourier transformation (1- along each column, 2 - along each row)
*@return a matrix generated by Fourier transform of the input matrix
*@ramark Compute the Fourier transform along the dimension dim. See https://www.mathworks.com/help/matlab/ref/fft.html.
*/
template<typename OutputDerived = Eigen::TMatrixXc, typename ComplexInputDerived>
OutputDerived fft(const Eigen::MatrixBase<ComplexInputDerived>& X, int n, int dim)
{
	assert(dim == 1 || dim == 2);
	auto rows = X.rows();
	auto cols = X.cols();
	// along each column 
	
	if (dim == 1)
	{
		OutputDerived om(n, cols);
		using Vector = Eigen::Matrix<typename ComplexInputDerived::Scalar, -1, 1>;
		for (Eigen::Index i = 0; i < cols; i++)
		{	
			om.col(i) = fft < Eigen::Matrix<typename OutputDerived::Scalar, -1, 1>>(concat<Vector>(X.col(i), Vector::Zero(n - X.rows()), Eigen::Vertical)) ;
		}
		return om;
	}
	// along each row
	else
	{
		OutputDerived om(rows, n);
		using RowVector = Eigen::Matrix<typename ComplexInputDerived::Scalar, 1, -1>;
		for (Eigen::Index i = 0; i < rows; i++)
		{
			om.row(i) = fft < Eigen::Matrix<typename OutputDerived::Scalar, 1, -1>>(concat<RowVector>(X.row(i), RowVector::Zero(n - X.cols()), Eigen::Horizontal));
		}
		return om;
	}
}


/**
 * Inverse fast Fourier transform. Implementation of ifft in MATLAB.
 *@tparam OutputVector the output vector type, defaut to be Eigen::TRowVectorXc
 *@tparam InputDerived input vector type
 *@param X input vector
 *@return a vector generated by inverse Fourier transform of the input vector 
 *@ramark Unlike fft of MATLAB, this function only supports vector input and vector output. See https://www.mathworks.com/help/matlab/ref/fft.html.
 *@note when the input vector is of real type, the output vector may be complex
*/
template<typename OutputVector = Eigen::TRowVectorXc, typename ComplexInputDerived>
OutputVector ifft(const Eigen::MatrixBase<ComplexInputDerived>& X)
{
	using Scalar = typename OutputVector::RealScalar;
	Eigen::FFT<Eigen::TFloat> fftTransformation;
	OutputVector output(X.size());
	fftTransformation.inv(output, X);
	return output;
}





